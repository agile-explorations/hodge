/**
 * Review Config Generator
 *
 * Generates .hodge/review-config.md with auto-detected profiles and metadata.
 */

import fs from 'fs-extra';
import path from 'path';
import type { DetectionResult } from './auto-detection-service.js';
import { createCommandLogger } from './logger.js';

/**
 * Options for generating review config
 */
export interface GenerateOptions {
  /** Include auto-detection results section */
  includeDetectionResults?: boolean;

  /** Include manual customization instructions */
  includeInstructions?: boolean;
}

/**
 * Service for generating review-config.md
 */
export class ReviewConfigGenerator {
  private logger = createCommandLogger('review-config-generator', { enableConsole: false });

  /**
   * Creates a new ReviewConfigGenerator
   * @param hodgeDir - Path to .hodge directory
   */
  constructor(private hodgeDir: string) {}

  /**
   * Generate review-config.md with detected profiles
   *
   * @param detectionResults - Results from auto-detection
   * @param options - Generation options
   */
  async generate(
    detectionResults: DetectionResult[],
    options: GenerateOptions = {}
  ): Promise<void> {
    const { includeDetectionResults = true, includeInstructions = true } = options;

    this.logger.debug('Generating review-config.md', {
      detectedProfiles: detectionResults.filter((r) => r.detected).length,
      totalChecked: detectionResults.length,
    });

    // Filter to detected profiles only
    const detectedProfiles = detectionResults.filter((r) => r.detected);

    // Group profiles by category (from path)
    const profilesByCategory = this.groupProfilesByCategory(detectedProfiles);

    // Build markdown content
    const content = this.buildMarkdownContent(
      profilesByCategory,
      detectionResults,
      includeDetectionResults,
      includeInstructions
    );

    // Write to file
    const configPath = path.join(this.hodgeDir, 'review-config.md');
    await fs.writeFile(configPath, content, 'utf-8');

    this.logger.debug('review-config.md generated', { path: configPath });
  }

  /**
   * Group profiles by category (e.g., languages, frameworks, databases)
   *
   * @param results - Detection results for detected profiles
   * @returns Profiles grouped by category
   */
  private groupProfilesByCategory(results: DetectionResult[]): Map<string, DetectionResult[]> {
    const grouped = new Map<string, DetectionResult[]>();

    for (const result of results) {
      // Extract category from path (e.g., "languages/typescript.md" → "languages")
      const parts = result.profile.path.split(/[/\\]/);
      const category = parts.length > 1 ? parts[0] : 'general';

      if (!grouped.has(category)) {
        grouped.set(category, []);
      }

      grouped.get(category)!.push(result);
    }

    return grouped;
  }

  /**
   * Build markdown content for review-config.md
   *
   * @param profilesByCategory - Profiles grouped by category
   * @param allResults - All detection results (for diagnostics)
   * @param includeDetectionResults - Whether to include detection results section
   * @param includeInstructions - Whether to include manual customization instructions
   * @returns Markdown content
   */
  private buildMarkdownContent(
    profilesByCategory: Map<string, DetectionResult[]>,
    allResults: DetectionResult[],
    includeDetectionResults: boolean,
    includeInstructions: boolean
  ): string {
    const lines: string[] = [];

    // Frontmatter
    lines.push('---');
    lines.push('version: "1.0.0"');
    lines.push(`created_by: hodge init`);
    lines.push(`last_updated: "${new Date().toISOString()}"`);
    lines.push('auto_detected: true');
    lines.push('---');
    lines.push('');

    // Header
    lines.push('# Review Configuration');
    lines.push('');
    lines.push('This file specifies which review profiles to use for this project.');
    lines.push('Generated by `hodge init` based on project structure.');
    lines.push('');

    // Active Profiles section
    lines.push('## Active Profiles');
    lines.push('');

    // Define category order for logical grouping
    const categoryOrder = [
      'languages',
      'frameworks',
      'databases',
      'ui-libraries',
      'api-styles',
      'testing',
      'build-tools',
      'linting',
      'general',
    ];

    // Iterate categories in order
    for (const category of categoryOrder) {
      const results = profilesByCategory.get(category);
      if (!results || results.length === 0) continue;

      // Category heading
      const categoryTitle = this.formatCategoryTitle(category);
      lines.push(`### ${categoryTitle}`);
      lines.push('');

      // List profiles
      for (const result of results) {
        const profileName = path.basename(result.profile.path, '.md');
        lines.push(`- \`${result.profile.path}\` - ${this.formatProfileName(profileName)}`);
      }
      lines.push('');
    }

    // Auto-Detection Results section
    if (includeDetectionResults) {
      lines.push('## Auto-Detection Results');
      lines.push('');
      lines.push('Detected during `hodge init`:');
      lines.push('');

      const detectedResults = allResults.filter((r) => r.detected);

      for (const result of detectedResults) {
        const profileName = path.basename(result.profile.path, '.md');
        lines.push(`- **${this.formatProfileName(profileName)}**: ${result.reason}`);
      }
      lines.push('');
    }

    // Manual Customization section
    if (includeInstructions) {
      lines.push('## Manual Customization');
      lines.push('');
      lines.push('You can add or remove profiles by editing the Active Profiles section above.');
      lines.push('Changes are preserved when running `hodge init --update` (future feature).');
      lines.push('');
      lines.push('To add a profile manually:');
      lines.push('1. Find the profile in the Hodge profiles library');
      lines.push('2. Add it to the appropriate category above');
      lines.push('3. The review command will automatically include it');
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Format category name for display (e.g., "ui-libraries" → "UI Libraries")
   *
   * @param category - Category slug
   * @returns Formatted category title
   */
  private formatCategoryTitle(category: string): string {
    return category
      .split('-')
      .map((word) => {
        // Special cases
        if (word === 'ui') return 'UI';
        if (word === 'api') return 'API';

        // Title case
        return word.charAt(0).toUpperCase() + word.slice(1);
      })
      .join(' ');
  }

  /**
   * Format profile name for display (e.g., "typescript" → "TypeScript")
   *
   * @param profileName - Profile filename without extension
   * @returns Formatted profile name
   */
  private formatProfileName(profileName: string): string {
    // Special cases for common names
    const specialCases: Record<string, string> = {
      typescript: 'TypeScript',
      javascript: 'JavaScript',
      graphql: 'GraphQL',
      mui: 'Material-UI (MUI)',
      'chakra-ui': 'Chakra UI',
      tailwind: 'Tailwind CSS',
      'ant-design': 'Ant Design',
      nestjs: 'NestJS',
      nextjs: 'Next.js',
      vuejs: 'Vue.js',
      reactjs: 'React.js',
      trpc: 'tRPC',
      typeorm: 'TypeORM',
      mongodb: 'MongoDB',
      postgresql: 'PostgreSQL',
      mysql: 'MySQL',
      eslint: 'ESLint',
      prettier: 'Prettier',
    };

    if (specialCases[profileName.toLowerCase()]) {
      return specialCases[profileName.toLowerCase()];
    }

    // Default: title case with hyphens as spaces
    return profileName
      .split('-')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }
}
