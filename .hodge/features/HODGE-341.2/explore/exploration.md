# Exploration: HODGE-341.2

## Feature Overview
**Title**: Advanced Tool Integration (Complexity, Duplication, Architecture, Security)
**PM Issue**: HODGE-341.2
**Type**: sub-feature (child of HODGE-341)
**Created**: 2025-10-11T06:09:50.904Z

## Problem Statement

Extend the toolchain infrastructure from HODGE-341.1 to include advanced quality checks that catch complexity issues, code duplication, architectural violations, and security/framework patterns - going beyond basic linting and type-checking to provide comprehensive code quality analysis.

HODGE-341.1 established the foundational ToolchainService with basic tool detection (TypeScript, ESLint, Prettier, Vitest). Phase 2 adds four advanced tools that address the gaps:
- **eslint-plugin-sonarjs**: Cognitive complexity and code smells
- **jscpd**: Copy-paste detection across files
- **dependency-cruiser**: Module dependency analysis and architectural boundaries
- **Semgrep**: Security patterns and framework-specific anti-patterns

These tools run first (0 AI tokens), produce raw output, then AI reviews the output to provide insights and fixes. No parsing needed - AI reads raw tool output naturally.

## Context
- **Standards**: Loaded (suggested only)
- **Available Patterns**: 12
- **Parent Feature**: HODGE-341 (Hybrid Code Quality Review System)
- **Shipped Sibling**: HODGE-341.1 (Core Toolchain Infrastructure)
- **Similar Features**: HODGE-327.2, hodge-branding, HODGE-001

## Conversation Summary

### Simplified Architecture Discovery

During exploration, we discovered that **parsing tool output is unnecessary complexity**. Tools already provide human-readable output, and AI can interpret it naturally. The architecture simplifies to:

1. **Tools run via ToolchainService** → configured in `toolchain.yaml`
2. **Capture exit codes + raw output** → no JSON parsing needed
3. **AI reads raw output** → interprets naturally like a developer would
4. **Pass rate = exit codes** → simple: `exit_code === 0` means pass

This eliminates the need to understand 30+ tool output formats across multiple languages.

### Two-Layer Configuration Architecture (Build Phase Discovery)

**Problem**: Initial build approach started adding hard-coded detection logic for each tool (eslint-plugin-sonarjs, jscpd, dependency-cruiser, Semgrep). Realized this doesn't scale - can't hardcode 30+ tools across multiple languages.

**Solution**: Separate Hodge's universal tool knowledge from project-specific configuration.

**Layer 1 - Tool Registry** (`src/bundled-config/tool-registry.yaml`):
- Ships with Hodge package (not user-editable)
- Contains universal tool information for ALL supported tools:
  - Detection rules (config files, package.json, PATH)
  - Installation commands per package manager (npm, pip, poetry, gradle, maven)
  - Default command templates with `${files}` placeholders
  - Version detection commands
  - Quality check categories (type_checking, linting, complexity, duplication, security, etc.)
  - Supported languages per tool

**Layer 2 - Project Toolchain** (`.hodge/toolchain.yaml`):
- Generated by `hodge init` for THIS specific project
- User-customizable commands (edit freely)
- Only contains tools actually detected in this project
- Users customize tool invocations, flags, config paths

**How Components Use This**:
- **`hodge init`**: Reads registry → detects tools → offers installation → generates toolchain.yaml with defaults
- **Review profiles**: Check toolchain.yaml to understand what tech is used in project
- **`/harden` and `/review`**: Execute commands from toolchain.yaml (don't need registry)
- **ToolchainService**: Generic detection engine that reads registry rules

**Benefits**:
- ✅ Scalable: Add 100 tools to registry without code changes
- ✅ Package manager agnostic: Registry knows npm, pip, poetry, gradle, maven
- ✅ No hardcoded tool lists in application code
- ✅ User customization preserved: toolchain.yaml is user's config file
- ✅ Review profiles can detect project tech stack from toolchain
- ✅ Works across languages: TypeScript, Python, Go, Rust, etc.

### Tool Configuration Strategy

All tools are configured in `toolchain.yaml` with user-customizable commands:

```yaml
commands:
  jscpd:
    command: npx jscpd ${files} --min-lines 10
    # User can customize: jscpd . --config custom.json --min-lines 20

  dependency-cruiser:
    command: npx depcruise src/ --config .dependency-cruiser.js
    # User can customize paths and config

  semgrep:
    command: semgrep --config .hodge/semgrep-rules/ ${files}
    # User can add custom rules, adjust config
```

Users edit the config file directly for customization. No hard-coded commands in Hodge.

### Tool Scoping Strategy

Tools use the `${files}` placeholder for file scoping:
- `/harden` command: `${files}` = uncommitted files
- `/review directory` command: `${files}` = files in specified directory
- `/review file` command: `${files}` = single file

For tools that need full project context:
- Run on entire project (e.g., dependency-cruiser always analyzes full module graph)
- AI filters results when reviewing output (sees file paths, focuses on relevant files)

Many tools have built-in scoping:
- `vitest --changed` runs only tests for changed files
- `eslint file1.ts file2.ts` runs only on specified files
- Tools configure their own scoping via command in `toolchain.yaml`

### Semgrep Bundled Framework Rules

We're building Semgrep rule files that will be bundled with Hodge and copied to `.hodge/semgrep-rules/` during init. The rules use a **hybrid versioning approach**:

**Universal Rules** (most patterns work across versions):
- `.hodge/semgrep-rules/prisma-anti-patterns.yaml` - N+1 queries, missing transactions
- `.hodge/semgrep-rules/react-anti-patterns.yaml` - Hook dependencies, inline functions
- `.hodge/semgrep-rules/graphql-anti-patterns.yaml` - DataLoader patterns

**Version-Specific Rules** (only where breaking changes matter):
- `.hodge/semgrep-rules/prisma-5.x.yaml` - Prisma 5+ specific patterns
- `.hodge/semgrep-rules/react-18.x.yaml` - React 18+ concurrent features

This respects the deferred version persistence decision from HODGE-341.1 (versions deferred to Phase 5) while laying groundwork for future version matching.

### Tool Installation Strategy

**npm-installable tools** (eslint-plugin-sonarjs, jscpd, dependency-cruiser):
- Ask permission to install
- Run `npm install --save-dev <tool>` if approved
- Provide clear installation command if declined

**External tools** (Semgrep):
- Recommend installation with documentation link
- Example: "⚠️ Semgrep not found. Install: https://semgrep.dev/docs/getting-started/"

### ToolchainService as Universal Tool Gateway

Key architectural principle: **ALL tool calls must go through ToolchainService**, configured via `toolchain.yaml`. This includes:
- Quality tools (eslint, tsc, vitest, jscpd, etc.)
- Source control (git) - future
- Build tools (npm, gradle, cargo) - future

**Phase 2 Scope**: Add the 4 new quality tools. Git refactoring deferred to future phase.

### Tool Availability Rules

Clear rules for handling missing tools:
- **Optional tool not in toolchain.yaml**: Warning, skip gracefully
- **Required tool not in toolchain.yaml** (e.g., git): Error, block execution
- **Tool in toolchain.yaml but not installed**: Error (user explicitly configured it)

**`hodge init` behavior**: Detect and configure ALL tools upfront (source control + quality tools).

### Multiple Executables Handling

For tools with multiple possible executables (git, node, python), use:
1. **Explicit path in toolchain.yaml** (user override) - highest priority
2. **Standard PATH resolution** - `which git` / `where git` (cross-platform)
3. **Common installation locations** - `/usr/bin/git`, `/usr/local/bin/git` (fallback)

Rationale: Respects user's environment (PATH reflects their setup), allows explicit override, cross-platform compatible.

## Implementation Approaches

### Approach 1: Simple Tool Execution (Recommended)

**Description**: Detect tools, execute via ToolchainService, capture raw output and exit codes. No parsing. AI reads raw output naturally.

**Implementation**:

1. **Tool Detectors** (in `src/lib/toolchain-service.ts`):
   ```typescript
   class JscpdDetector implements ToolDetector {
     async detect(): Promise<boolean> {
       return hasPackage('jscpd') || commandExists('jscpd');
     }

     getDefaultCommand(): string {
       return 'npx jscpd ${files} --min-lines 10';
     }
   }

   class DependencyCruiserDetector implements ToolDetector {
     async detect(): Promise<boolean> {
       return hasPackage('dependency-cruiser') || commandExists('depcruise');
     }

     getDefaultCommand(): string {
       return 'npx depcruise src/ --output-type err';  // Human-readable
     }
   }

   class SemgrepDetector implements ToolDetector {
     async detect(): Promise<boolean> {
       return commandExists('semgrep');
     }

     getDefaultCommand(): string {
       return 'semgrep --config .hodge/semgrep-rules/ ${files}';
     }
   }
   ```

2. **Tool Execution** (already in ToolchainService from HODGE-341.1):
   ```typescript
   class ToolchainService {
     async runTool(toolName: string, files?: string[]): Promise<ToolResult> {
       const config = this.config.commands[toolName];
       const command = this.substituteFiles(config.command, files);

       const result = await exec(command, {
         encoding: 'utf-8',
         maxBuffer: 10 * 1024 * 1024  // 10MB for large outputs
       });

       return {
         tool: toolName,
         exitCode: result.exitCode,
         stdout: result.stdout,
         stderr: result.stderr,
         passed: result.exitCode === 0,
         duration: result.duration
       };
     }
   }
   ```

3. **Result Aggregation** (simplified DiagnosticsService):
   ```typescript
   class DiagnosticsService {
     async runQualityChecks(files?: string[]): Promise<QualityReport> {
       const toolsToRun = ['typecheck', 'lint', 'test', 'complexity',
                           'duplication', 'architecture', 'security'];

       const results = await Promise.all(
         toolsToRun.map(tool => this.toolchain.runTool(tool, files))
       );

       return {
         timestamp: new Date().toISOString(),
         files_scoped: files?.length || 'all',
         results: results,
         pass_rate: results.filter(r => r.passed).length / results.length * 100,
         summary: this.generateSummary(results)
       };
     }

     private generateSummary(results: ToolResult[]): string {
       const passed = results.filter(r => r.passed).length;
       const failed = results.length - passed;

       return `${passed}/${results.length} checks passed\n\n` +
         results.map(r =>
           `${r.passed ? '✅' : '❌'} ${r.tool}: ${r.passed ? 'PASSED' : 'FAILED'}`
         ).join('\n');
     }
   }
   ```

4. **AI Review Integration** (raw output, no parsing):
   ```markdown
   # Quality Check Results for HODGE-341.2

   Pass Rate: 75% (6/8 checks passed)

   ## ✅ Type Checking (PASSED)
   Exit code: 0
   Duration: 2.3s
   Output: (no errors)

   ## ❌ Linting (FAILED)
   Exit code: 1
   Duration: 1.8s
   Output:
   /Users/michael/src/toolchain-service.ts
     45:12  error  'result' is not defined  no-undef
     78:5   warning  Unexpected console statement  no-console

   ## ✅ Duplication Detection (PASSED)
   Exit code: 0
   Duration: 3.1s
   Output:
   Found 0 exact duplicates
   Found 2 similar code blocks (below threshold)

   ## ❌ Architecture Validation (FAILED)
   Exit code: 1
   Duration: 1.2s
   Output:
   Dependency Violations:
   src/commands/harden.ts → src/lib/internal-utils.ts
     Violates rule: commands should not import from lib/internal
   ```

   AI reads this naturally, understands context, suggests fixes.

5. **Bundled Semgrep Rules** (in `src/bundled-rules/semgrep/`):
   ```yaml
   # prisma-anti-patterns.yaml
   rules:
     - id: prisma-n-plus-one
       pattern: |
         for ($ITEM of $ITEMS) {
           await prisma.$MODEL.findMany(...)
         }
       message: "N+1 query detected - use include/select"
       severity: ERROR
       languages: [typescript, javascript]

     - id: prisma-missing-transaction
       pattern: |
         await prisma.$MODEL.create(...)
         await prisma.$OTHER.create(...)
       message: "Related writes should use transaction"
       severity: WARNING
       languages: [typescript, javascript]
   ```

6. **Extend toolchain.yaml schema**:
   ```yaml
   # .hodge/toolchain.yaml (generated by hodge init)
   version: "1.0"
   language: typescript

   commands:
     typescript:
       command: npx tsc --noEmit
       detected: true

     eslint:
       command: npx eslint ${files}
       detected: true

     eslint-plugin-sonarjs:
       command: null  # Runs via eslint
       detected: true

     jscpd:
       command: npx jscpd ${files} --min-lines 10
       detected: true

     dependency-cruiser:
       command: npx depcruise src/ --output-type err
       detected: true

     semgrep:
       command: semgrep --config .hodge/semgrep-rules/ ${files}
       detected: false  # External tool

   quality_checks:
     type_checking: [typescript]
     linting: [eslint]
     testing: [vitest]
     formatting: [prettier]
     complexity: [eslint-plugin-sonarjs]
     code_smells: [eslint-plugin-sonarjs]
     duplication: [jscpd]
     architecture: [dependency-cruiser]
     security: [semgrep]
   ```

**Pros**:
- **Dramatically simpler**: No parsing logic for 30+ tools
- **Flexible**: AI interprets any output format naturally
- **Maintainable**: Tool output format changes don't break Hodge
- **User-customizable**: Edit `toolchain.yaml` directly for custom flags
- **Leverages AI strengths**: Natural language understanding of tool output
- **Exit code reliability**: Simple pass/fail based on standard exit codes

**Cons**:
- Less structured data for programmatic analysis
- Pass rate is binary (pass/fail) not severity-weighted
- Can't programmatically count specific issue types

**When to use**: This is the right approach when AI is the consumer of tool output. No need to structure data that AI will interpret anyway.

### Approach 2: Parse and Normalize Output

**Description**: Parse each tool's JSON output into a universal diagnostic format.

**Why we rejected this**:
- Requires understanding 30+ tool output formats across languages
- Brittle - breaks when tools change output format
- AI doesn't need structured data - it reads raw output better
- Massive implementation complexity for minimal benefit
- The pass rate calculation doesn't need detailed parsing (just exit codes)

**When to use**: If you need programmatic analysis of diagnostics outside of AI review (e.g., tracking metrics over time, generating charts). Not needed for HODGE-341's use case.

### Approach 3: Hybrid - Exit Codes + AI Parsing

**Description**: Capture exit codes for pass/fail, let AI parse output only when needed for deeper analysis.

**Why this is already what Approach 1 does**: AI naturally parses output during review. We capture everything (exit codes + raw output), AI decides what to extract.

## Recommendation

**Approach 1: Simple Tool Execution** is recommended because:

1. **Minimal Complexity**: No parsing logic, just run tools and capture output
2. **AI-Friendly**: Raw tool output is exactly what AI reads naturally
3. **Future-Proof**: Tool format changes don't break Hodge
4. **User Control**: `toolchain.yaml` allows full command customization
5. **Fast Implementation**: HODGE-341.1 already has execution infrastructure, just add detectors

The complexity of parsing 30+ tool formats across multiple languages is unnecessary when AI is the consumer. Let AI do what it's good at: understanding human-readable text.

## Test Intentions

Behavioral expectations for HODGE-341.2:

1. **Tool Detection**: When `hodge init` runs, it detects eslint-plugin-sonarjs, jscpd, dependency-cruiser, and Semgrep (if installed)

2. **Tool Installation Offer**: When a npm-installable tool is missing, hodge asks permission and installs if approved

3. **Configuration Generation**: Detected tools are added to `.hodge/toolchain.yaml` with appropriate default commands and `${files}` placeholders

4. **Tool Execution**: ToolchainService can execute all four new tools and capture exit codes + raw output

5. **Pass Rate Calculation**: Pass rate is calculated from exit codes (0 = pass) and includes all tool checks

6. **Raw Output Capture**: Full stdout and stderr from each tool is captured for AI review

7. **Bundled Semgrep Rules**: Universal framework rules (Prisma, React, GraphQL) are bundled and copied to `.hodge/semgrep-rules/` during init

8. **Missing Tool Warning**: When an optional tool isn't configured, execution continues with a clear warning

9. **Missing Required Tool Error**: When a required tool (like git) isn't configured, execution fails with actionable error

10. **User Customization**: Users can edit commands in `toolchain.yaml` and Hodge uses the customized commands

## Decisions Decided During Exploration

1. ✓ **No output parsing**: Capture raw output and exit codes only, let AI interpret naturally

2. ✓ **Tool configuration**: All commands in `toolchain.yaml`, user-editable for customization

3. ✓ **File scoping**: Use `${files}` placeholder, let tools handle scoping via their own flags

4. ✓ **Semgrep rule versioning**: Hybrid approach - universal rules for patterns that work across versions, version-specific rules only where breaking changes matter

5. ✓ **Tool installation**: Auto-install npm-installable tools with permission, recommend external tools with documentation links

6. ✓ **ToolchainService scope**: Phase 2 adds 4 new quality tools through ToolchainService, git refactoring deferred to future phase

7. ✓ **Multiple executables**: Use PATH resolution with toolchain.yaml override capability (respects user environment, cross-platform)

8. ✓ **Tool availability rules**: Optional tool not configured = warning; required tool missing = error; tool configured but not installed = error

## Decisions Needed

1. **Semgrep bundled rules scope**: How many rules per framework?
   - **Option A - Focused**: 2-3 high-value rules per framework (Prisma N+1, React hooks, GraphQL DataLoader) = ~8-10 total rules, ship quickly
   - **Option B - Comprehensive**: 5-7 rules per framework = ~20 rules, more thorough coverage
   - **Option C - Single Framework Deep**: Pick React or Prisma, build 10+ rules as reference pattern, document how users extend

2. **Tool detector priority for eslint-plugin-sonarjs**: Should detection check for:
   - **Option A**: Both devDependencies AND .eslintrc plugin configuration (most thorough)
   - **Option B**: Prioritize .eslintrc config presence (proves active usage)
   - **Option C**: Prioritize devDependencies (simpler detection)

## Next Steps
- [ ] Use `/decide` to resolve the two open decisions
- [ ] Proceed to `/build HODGE-341.2` with Approach 1

---
*Exploration completed: 2025-10-11*
*AI exploration based on conversational discovery*
*Revised: Simplified to raw output capture, no parsing*
